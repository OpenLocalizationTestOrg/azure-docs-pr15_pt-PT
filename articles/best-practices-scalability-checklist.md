<properties
   pageTitle="Lista de verificação escalabilidade | Microsoft Azure"
   description="Escalabilidade lista de verificação seta de quatro pontas preocupações de estrutura para Azure Autoscaling."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="scalability-checklist"></a>Lista de verificação escalabilidade

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="service-design"></a>Estrutura de serviço
- **Partição a carga de trabalho**. Estruturar partes do processo para ser descontínuos e decomposable. Minimize o tamanho de cada peça ao seguir as regras para separação de preocupações e o princípio responsabilidade única habituais. Esta opção permite-as partes de componente ser distribuído de uma forma que maximize a utilização de cada unidade de cluster (tal como um servidor de base de dados ou função). Também torna mais fácil dimensionar a aplicação adicionando instâncias de recursos específicos. Para mais informações, consulte o artigo [Calcular orientações a partições](https://msdn.microsoft.com/library/dn589773.aspx).
- **Design de dimensionamento**. Dimensionamento permite que as aplicações de responder carga variável ao aumentar e diminuir o número de ocorrências de funções, filas e outros serviços utilizar. No entanto, a aplicação deve ser concebida com este deve ter em conta. Por exemplo, a aplicação e os serviços que utilize o tem de ser sem estado para permitir que os pedidos ser encaminhado para qualquer ocorrência. Isto também impede a adição ou remoção de instâncias específicas adverso que afetam os utilizadores atuais. Deverá também implementar configuração ou detecção automática de instâncias à medida que são adicionados ou removidos, para que o código na aplicação pode executar o encaminhamento necessárias. Por exemplo, uma aplicação web poderá utilizar um conjunto de filas numa abordagem round robin para encaminhar pedidos para serviços de fundo a ser executada em funções de trabalho. A aplicação web tem de conseguir detetar alterações no número de filas, para encaminhar pedidos e equilibrar a carga sobre a aplicação com êxito.
- **Escala como uma unidade**. Plano de recursos adicionais acomodar crescimento. Para cada recurso saber o canto superior dimensionamento limites e utilize sharding ou decomposição para ir além estes limites. Determine as unidades da escala para o sistema em termos bem definidos conjuntos de recursos. Isto faz liquidação operações de escala de saída mais fácil e menos sujeito a impacto negativo à aplicação através de limitações impostos pelo falta de recursos no alguma parte do sistema global. Por exemplo, adicionar x número de funções web e trabalhador poderá ser necessário número de y de filas adicionais e o número de z de contas de armazenamento para processar a carga de trabalho adicional gerada pelas funções. Para uma unidade de escala poderia consistir x funções web e trabalhador, filas _y_ e _z_ armazenamento contas. Estruture a aplicação para que-la facilmente está dimensionada ao adicionar um ou mais unidades de escala.
- **Evite afinidade do cliente**. Sempre que possível, certifique-se de que a aplicação não requer afinidade. Pedidos, pelo que podem ser encaminhados para qualquer instância e o número de instâncias é irrelevante. Isto também evita gerais de armazenamento, retrieving e manter as informações de estado para cada utilizador.
- **Tirar partido das funcionalidades de autoscaling plataforma**. Onde a plataforma de alojamento suporta uma capacidade de autoscaling, tal como Azure Autoscale, prefere mecanismos personalizados ou de terceiros, a menos que o mecanismo incorporado não consegue processar seus requisitos. Utilizar regras de dimensionamento agendadas onde possíveis para se certificar de recursos estão disponíveis sem um atraso de arranque, mas adicionar autoscaling reactivar para as regras adequado fazer face inesperadas alterações no pedido. Pode utilizar as operações de autoscaling na API de gestão do serviço para ajustar autoscaling e para adicionar contadores personalizados para regras. Para mais informações, consulte [orientações dimensionamento automática](best-practices-auto-scaling.md).
- **Descarregar intensivos CPU/IO tarefas como tarefas em segundo plano**. Se um pedido para um serviço é esperado demorar muito tempo para executar ou absorve recursos consideráveis, descarregar o processamento para este pedido para uma tarefa em separado. Utilize funções de trabalho ou tarefas em segundo plano (consoante a plataforma de alojamento) para executar as seguintes tarefas. Esta estratégia ativa o serviço para continuar a receber ainda mais os pedidos e permanecem responder.  Para mais informações, consulte [orientações de tarefas do fundo](best-practices-background-jobs.md).
- **Distribuir a carga de trabalho para tarefas em segundo plano**. Onde existem muitas tarefas em segundo plano ou as tarefas que requerem bastante tempo ou recursos, distribuir o trabalho por múltiplas unidades cluster (como as funções de trabalho ou tarefas em segundo plano). Para uma possível solução, consulte o [Padrão de consumidores competir](https://msdn.microsoft.com/library/dn568101.aspx).
- **Considere mover no sentido um _nada partilhado_ arquitetura**. Uma arquitetura de nada partilhado utiliza independentes, auto-suficientes nós que não tenham nenhum ponto único da contenção (como serviços partilhados ou armazenamento). Em teoria, como um sistema pode dimensionar quase indefinidamente. Enquanto uma abordagem de nada de partilhado totalmente não é geralmente prática para a maioria das aplicações, pode fornecer-se de oportunidades para estruturar o melhor escalabilidade. Por exemplo, evitar a utilização do Estado da sessão do lado do servidor, afinidade do cliente e a partições de dados são boas exemplos de contribui para a uma arquitetura de nada partilhado.

## <a name="data-management"></a>Gestão de dados

- **Utilizar dados a partições**. Dividir os dados em múltiplas bases de dados e os servidores de base de dados ou estrutura, a aplicação para utilizar o armazenamento de dados dos serviços que pode fornecer este partições transparente (alguns exemplos incluem Azure SQL flexível bases de dados e armazenamento de tabela do Azure). Esta abordagem pode ajudar a maximizar o desempenho e permitir dimensionamento mais fácil. Existem diferentes a partições técnicas, tal como horizontal, vertical e funcional. Pode utilizar uma combinação dos seguintes procedimentos para alcançar máximo benefício a partir do desempenho da consulta maior, escalabilidade mais simples, gestão mais flexível, melhor disponibilidade e para corresponder ao tipo de arquivo para os dados vai introduzir. Além disso, considere utilizar diferentes tipos de arquivo de dados para diferentes tipos de dados, escolha os tipos de com base em bem como estão otimizados para o tipo específico de dados. Isto pode incluir a utilizar o armazenamento de tabela, uma base de dados do documento ou um arquivo de dados de coluna família, em vez de, ou, bem como uma base de dados relacional. Para mais informações, consulte [orientações partições de dados](best-practices-data-partitioning.md).
- **Estrutura de consistência eventual**. Consistência eventual melhora escalabilidade ao reduzir ou remover o tempo necessário para sincronizar os dados relacionados a partições através de vários stores. O custo é que dados não não sempre consistentes quando é lido e algumas escrever operações podem causar conflitos. Consistência eventual é ideal para situações em que os mesmos dados são frequentemente a ler mas escritos com pouca frequência. Para obter mais informações, consulte a [Introdução de consistência de dados](https://msdn.microsoft.com/library/dn589800.aspx).
- **Reduzir chatty interações entre componentes e serviços**. Evite estruturar interações em que uma aplicação é necessário para efetuar chamadas de vários para um serviço (cada um dos quais devolve uma pequena quantidade de dados), em vez de uma chamada única que pode devolver todos os dados. Sempre que possível, combine várias operações relacionadas num único pedido quando a chamada está a um serviço ou componente que tenha latência evidente. Isto torna mais fácil monitorizar o desempenho e otimizar operações complexas. Por exemplo, utilize os procedimentos armazenados nas bases de dados para incorporar lógica complexa e reduzir o número de viagens round e bloquear do recurso.
- **Utilizar filas para nivelar a carga de alta velocidade dados escritas**. Flutuações da procura para um serviço podem sobrecarregar desse serviço e causar falhas escalonamento. Para evitar esta situação, considere o [padrão de nivelamento de carga baseados em filas](https://msdn.microsoft.com/library/dn589783.aspx)de execução. Utilize uma fila que age como um intervalo de tempo entre uma tarefa e de um serviço que chama-lo. Isto pode uniformizar intermitentes cargas intenso que caso contrário, podem causar o falha do serviço ou a tarefa expire.
- **Minimizar a carregar no arquivo de dados**. O arquivo de dados é frequentemente um congestionamento processamento, um recurso dispendioso, muitas vezes não fácil e a escala saída. Sempre que possível, remova a lógica (por exemplo, processamento de documentos XML ou objetos JSON) a partir da loja de dados e executar o processamento dentro da aplicação. Por exemplo, em vez de passagem XML para a base de dados (diferente de como uma cadeia opaca para armazenamento), serializar ou serialização XML dentro a camada de aplicação e passam-lo num formulário que é nativa para o arquivo de dados. É normalmente muito mais fácil Dimensionar saída a aplicação que o arquivo de dados, para que deverá tentar fazer como muita o processamento de cluster-a com um grau elevado possível dentro da aplicação.
- **Minimizar o volume de dados obtidos**. Recuperar apenas os dados que requerem especificando colunas e a utilização de critérios para selecionar linhas. Facilitam a utilização de parâmetros de valor de tabela e o nível de isolamento adequado. Mecanismos de utilizar como etiquetas de entidade para evitar a obtenção de dados desnecessariamente.
- **Utilizar agressivamente colocação em cache**. Utilize a colocação em cache sempre que possível reduzir a carga recursos e serviços que geram ou fornecer dados. Colocação em cache normalmente é adequada para dados que forem relativamente estático ou que necessita de processamento considerável para obter. Colocação em cache deve ocorrer em todos os níveis eventualmente em cada camada de aplicação, incluindo geração de interface de dados access e o utilizador. Para obter mais informações, consulte as [Orientações colocação em cache](best-practices-caching.md).
- **Processar crescimento de dados e retenção**. Aumenta a quantidade de dados armazenados por uma aplicação ao longo do tempo. Este crescimento aumenta custos de armazenamento e aumenta latência quando aceder aos dados — que afeta o modo débito de aplicação e o desempenho. Poderá ser possível periodicamente alguns dos dados antigos que já não são acedidos arquivar ou mover os dados que raramente são acedidos para armazenamento a longo prazo que é o custo mais eficientes, mesmo se for superior a latência de acesso.
- **Otimizar transferir objetos de dados (DTOs) utilizando um formato binário eficiente**. DTOs são transmitidos entre as camadas de uma aplicação do número de vezes. Minimizar o tamanho diminui a carga no recursos e da rede. No entanto, equilibre poupanças com sobrecarga de converter os dados no formato necessário em cada localização onde é utilizado. Aprovar um formato que tem a interoperabilidade máxima a permitir a fácil reutilização de um componente.
- **Definir o controlo de cache**. Estruturar e configurar a aplicação para utilizar a cache de saída ou fragmento de colocação em cache sempre que possível, para minimizar a carga de processamento.
- **Ativar colocação em cache do lado do cliente**. Aplicações Web deverão ativar definições de cache no conteúdo que pode ser colocada em cache. Normalmente isto é desativado por predefinição. Configure o servidor para entregar a cache adequada cabeçalhos de controlo para activar a cache de conteúdo em servidores proxy e clientes.
- **Armazenamento de Blobs do Azure de utilização e a rede de entrega de conteúdos do Azure para reduzir a carga da aplicação**. Considere armazenar conteúdo público estático ou relativamente estático, tais como imagens, scripts, recursos e folhas de estilo, armazenamento de Blobs. Esta abordagem liberta a aplicação de carga causada pela dinamicamente gerar este conteúdo para cada pedido. Para além disso, considere utilizar a rede de entrega de conteúdos para este conteúdo em cache e transmiti-lo a clientes. Utilizar a rede de entrega de conteúdo pode melhorar o desempenho no cliente, uma vez que o conteúdo é entregue a partir do Centro de dados geograficamente mais próximo que contém uma cache de rede de entrega de conteúdos. Para obter mais informações, consulte as [Orientações de rede de entrega de conteúdos](best-practices-cdn.md).
- **Otimizar e consultas SQL de sintonização e índices**. Alguns instruções T SQL ou construções podem ter um impacto no desempenho pode ser reduzido por otimizar o código de um procedimento armazenado. Por exemplo, evite converter tipos de **data/hora** para um **varchar** antes de comparar com um valor literal de **data/hora** . Utilize funções de comparação de data/hora. Falta de índices adequados também pode abrandar a execução da consulta. Se utilizar um quadro de mapeamento objeto relacionais, compreenda como funciona e como pode afectar camada de acesso a dados de desempenho. Para mais informações, consulte o artigo [Optimização da consulta](https://technet.microsoft.com/library/ms176005.aspx).
- **Considere normalizar retirar dados**. Normalização dados ajuda a evitar duplicação e inconsistência. No entanto, manutenção de múltiplos índices, verificar a existência de integridade referencial, efetuar várias acessos para pequenas blocos de dados e participar tabelas reagrupar pelos dados impõe uma sobrecarga que pode afetar o desempenho. Considere se alguns volume de armazenamento adicional e duplicação for aceitável para reduzir a carga no arquivo de dados. Além disso, considere se a própria aplicação (que é normalmente mais fácil dimensionar) pode ser-lhe oposta para assumir o controlo de tarefas, como gerir a integridade referencial para poder reduza a carga no arquivo de dados. Para mais informações, consulte [orientações partições de dados](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).

## <a name="service-implementation"></a>Implementação do serviço
- **Chamadas assíncronas utilização**. Utilize código assíncrono sempre que possível quando aceder a recursos ou serviços que podem ser limitados por e/s ou largura de banda de rede ou que tenham uma latência evidente, para evitar a bloquear o tópico de chamada. Para implementar operações assíncronas, utilize a [Baseado em tarefas assíncrona padrão (TOQUE)](https://msdn.microsoft.com/library/hh873175.aspx).
- **Evitar o bloqueio de recursos e como alternativa, utilize uma abordagem de optimista**. Nunca bloqueia o acesso a recursos, tais como o armazenamento ou de outros serviços que tenham latência evidente, uma vez que esta é uma causa principal do desempenho baixa. Utilize sempre optimistas abordagens para gerir operações em simultâneo, por exemplo, ao armazenamento de escrita. Utilize funcionalidades da camada de armazenamento para gerir conflitos. Em aplicações distribuídas, dados podem ser só são eventualmente consistentes.
- **Comprimir altamente comprimível dados ao longo de latência alta, redes de largura de banda baixa**. Na maioria dos casos numa aplicação web, o volume mais alto de dados gerada pela aplicação e transmitido através da rede está HTTP as respostas a pedidos de cliente. A compressão de HTTP pode reduzir isto consideravelmente, especialmente para em conteúdo estático. Isto pode reduzir custo, bem como reduzir a carga de rede, apesar de comprimir conteúdo dinâmico aplicam-se numa fractionally maior carga no servidor. Em outros, mais ambientes GRG, compressão de dados pode reduzir o volume de dados transmitidos e minimizar o tempo de transferência e custos, mas os processos de compressão e descompressão implicam gerais. Como tal, compressão só deverá ser utilizada quando existe um ganho demonstrável no desempenho. Outros métodos de serialização, tal como JSON ou codificações binárias, podem reduzir o tamanho de carga útil enquanto está a ter menos impacto no desempenho, Considerando que XML é provável que para aumentá-la.
- **Minimizar o tempo que ligações e recursos estão a ser utilizados**. Manter as ligações e recursos apenas para desde que precisa para utilizá-los. Por exemplo, abra possível ligações e permitir que este ser devolvido ao agrupamento de ligação mais cedo possível. Adquirir mais tarde possível recursos e colocá-las mais cedo possível.
- **Minimizar o número de ligações necessário**. Ligações de serviço absorvem recursos. Limite o número que são necessários e certifique-se de que as ligações existentes são reutilizadas sempre que possível. Por exemplo, após efetuar autenticação, utilize a representação adequado executar código como uma identidade específica. Isto pode ajudar a tornar melhor utilização do agrupamento de ligação ao reutilizar ligações.

    > [AZURE.NOTE]: APIs for some services automatically reuse connections, provided service-specific guidelines are followed. It's important that you understand the conditions that enable connection reuse for each service that your application uses.

- **Enviar pedidos em lotes para otimizar o uso de rede**. Por exemplo, enviar e ler mensagens em lotes ao aceder a uma fila e executar várias lê ou escritas como um lote de ao aceder ao armazenamento ou uma cache. Isto pode ajudar a maximizar eficiência dos arquivos de serviços e dados, reduzindo o número de chamadas através da rede.
- **Evite um requisito para armazenar o estado de sessão do lado do servidor** sempre que possível. Gestão de sessões do lado do servidor de estado normalmente requer afinidade do cliente (isto é, encaminhamento de cada pedido na mesma instância de servidor), que afeta a capacidade do sistema para dimensionar. Idealmente, deve conceber clientes a não ter estado relativamente às servidores que utilizam. No entanto, se a aplicação tem de manter o estado da sessão, guardar dados sensíveis ou grandes volumes de dados-client uma cache distribuída do lado do servidor que podem aceder a todas as instâncias da aplicação.
- **Esquemas de armazenamento de tabela de otimização**. Quando utilizar lojas de tabela que requerem os nomes de tabelas e colunas a ser transmitida e transformados com cada consulta, como o armazenamento de tabela do Azure, considere utilizar nomes mais pequenos para reduzir este gerais. No entanto, não o sacrifício legibilidade ou a capacidade de gestão utilizando nomes demasiado compactos.
- **Utilizar a tarefa paralelas biblioteca (NETUI) para efetuar operações assíncronas**. O NETUI torna mais fácil de escrever código assíncrono que efetua operações posso/the-ligadas. Utilize _ConfigureAwait(false)_ sempre que possível eliminar a dependência de continuação num contexto de sincronização específica. Este procedimento reduz as hipóteses de ocorrência de bloqueio de tópico.
- **Criar dependências de recursos durante a implementação, ou durante o arranque de aplicação**. Evite repetidas chamadas aos métodos que teste a existência de um recurso e, em seguida, criar o recurso se não existir. (Métodos como _CloudTable.CreateIfNotExists_ e _CloudQueue.CreateIfNotExists_ na biblioteca de cliente de armazenamento do Azure siga este padrão). Estes métodos podem impor sobrecarga considerável se estes estão chamados antes de cada acesso a uma tabela de armazenamento ou fila de armazenamento. Em alternativa:
 - Criar os recursos necessários quando a aplicação é implementada ou quando inicia pela primeira vez (uma chamada única para _CreateIfNotExists_ para cada recurso no código de arranque para uma função de web ou de trabalho for aceitável). No entanto, certifique-se de que processar exceções que podem surgir se o seu código tentativas para aceder a um recurso que não existe. Nas seguintes situações, deve iniciar sessão a exceção e, possivelmente alertar um operador qual um recurso está em falta.
 - Em determinadas circunstâncias, pode ser adequada criar o recurso em falta como parte de exceção código de processamento. Mas deverá tomar esta abordagem com cuidado à medida que não sejam existência do recurso pode ser indicativa de um erro de programação (um nome de recurso com erros ortográficos por exemplo) ou algumas outro problema de nível de infraestrutura.
- **Quadros lightweight utilização**. Escolha cuidadosamente APIs e quadros que utilizar para minimizar a utilização de recursos, tempo de execução e carga geral sobre a aplicação. Por exemplo, utilizando o Web API para gerir pedidos de serviço pode reduzir a menores de aplicação e aumentar a velocidade de execução, mas podem não ser adequado para obter cenários avançados onde as funcionalidades adicionais do Windows Communication Foundation são necessárias.
- **Considere minimizar o número de contas de serviço**. Por exemplo, utilize uma conta específica para aceder a recursos ou serviços que imponham um limite de ligações ou executar melhor onde ligações menos são mantidas. Esta abordagem é comuns para serviços como bases de dados, mas pode afetar à capacidade de auditoria com exatidão operações devido a representação do utilizador original.
- **Proceder a criação de perfis de desempenho e testes de carga** durante desenvolvimento, como parte de testes de rotina e antes da versão final para garantir que a aplicação executa e escalas conforme necessário. Este teste deve ocorrer no mesmo tipo de hardware como a plataforma de produção e com os mesmos tipos e quantidades de dados e o utilizador ser carregados como encontrará-se de produção. Para mais informações, consulte o artigo [testar o desempenho de um serviço na nuvem](vs-azure-tools-performance-profiling-cloud-services.md).
